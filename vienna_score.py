import RNA
from math import exp, log10
from params import design_parameters

def vienna_score(sequence:str, score_region:list, is_rna:bool, design_parameters:design_parameters) -> float:
    if len(sequence) != len(score_region):
        raise ValueError
    
    #Calculate cold temp for scoring
    cold_temp = design_parameters.target_temp-design_parameters.temp_offset
    if cold_temp < 0:
        cold_temp = 0
    if cold_temp >= 100:
        raise Exception("illegal cold temperature")
    
    #Calculate hot temp for scoring
    hot_temp = design_parameters.target_temp+design_parameters.temp_offset
    if hot_temp < 0:
        raise Exception("illegal hot temperature")
    if hot_temp > 100:
        hot_temp = 100

    scores_hot = vienna_score_temp(seq=sequence, score_region=score_region, temp=hot_temp,
        rna_concentration=design_parameters.rna_concentration,
        dimer_max_order_magnitude=design_parameters.dimer_max_order_magnitude,
        max_dimer_monomer_factor=design_parameters.max_dimer_monomer_factor,
        nucl_max_score=design_parameters.nucl_max_score, hot=True, is_rna=is_rna)
    scores_cold = vienna_score_temp(seq=sequence, score_region=score_region, temp=cold_temp,
        rna_concentration=design_parameters.rna_concentration,
        dimer_max_order_magnitude=design_parameters.dimer_max_order_magnitude,
        max_dimer_monomer_factor=design_parameters.max_dimer_monomer_factor,
        nucl_max_score=design_parameters.nucl_max_score, hot=False, is_rna=is_rna)

    score_energy = vienna_score_energy(seq=sequence, temp=design_parameters.thermo_score_temp,
        target_energy=design_parameters.target_energy,
        free_energy_max_score=design_parameters.free_energy_max_score, is_rna=is_rna)

    return score_energy + sum(scores_hot) + sum(scores_cold)

# Returns (float: score_nucl, float: ensemble_energy)
def vienna_score_temp(seq:str, score_region:list, temp: float, rna_concentration:float, dimer_max_order_magnitude:float, max_dimer_monomer_factor: float, nucl_max_score: float, hot: bool, is_rna: bool) -> tuple[float, float]:
    # If DNA needed, needs to be selected before RNA.md() called!
    if not is_rna:
        RNA.params_load_DNA_Mathews2004()
    else:
        RNA.params_load_defaults()
    model = RNA.md()
    model.temperature = temp
    model.compute_bpp = 1
    model.gquad = 1
    fc = RNA.fold_compound(seq, model)
    monomer_energy = fc.pf()[1]
    
    # NOTE! Vienna bpp array reports pairs from and onto in different positions of array.
    # TODO: verify that the NUPACK array doesn't behave like this, or scoring may be off!
    basepair_probs_diagonal = list()
    bpp = fc.bpp()
    for i in range(1, len(seq) + 1):
        basepair_probs_diagonal.append(0.0)
        for j in range(1, len(seq) + 1):
            basepair_probs_diagonal[i - 1] += bpp[i][j] + bpp[j][i]
    # TODO delete unnecessary check
    if len(basepair_probs_diagonal) != len(score_region):
        raise ValueError
    
    # Array was generated by summing probabilities of each nucl to be paired to another.
    # Needs to reflect the probability it is unpaired (i.e. smaller number results from more pairing)
    for i in range(len(basepair_probs_diagonal)):
        basepair_probs_diagonal[i] = 1 - basepair_probs_diagonal[i]
    
    score_nucl = 0
    count_scored_nuc = 0
    for i, x in enumerate(score_region):
        if x:
            score_nucl += basepair_probs_diagonal[i]
            count_scored_nuc+=1
    score_nucl = score_nucl / count_scored_nuc

    if score_nucl > nucl_max_score:
        score_nucl = nucl_max_score

    dimer_energy = vienna_dimer_energy(seq=seq, temp=temp)

    # Reaction: 2 Monomer <--> Dimer
    # Energies are in kcal / mol
    delta_g = dimer_energy - (2 * monomer_energy)

    # 1 kcal = 4184 J
    # R: 8.31446261815324 J / (mol * K)
    # Temp: in C, to K is + 273.15
    # delG = -RT lnQ --> Q = e^(-delG / RT)
    # Q = [DIMER] / [MONOMER]^2
    # [DIMER] / [MONOMER] = Q * [MONOMER]
    # log10(Q*[MONOMER]) + 2 to produce dimer_monomer_factor
    # For now, [MONOMER] fixed at 1e-6 (this is a key assumption) TODO mark as final constant
    # TODO mark the 1e-2 threshold for dimerization as a final constant

    dimer_monomer_factor = log10(exp((delta_g * -4184) / (8.31446261815324 * (273.15 + temp)) ) * rna_concentration) + dimer_max_order_magnitude
    if dimer_monomer_factor < 0:
        dimer_monomer_factor = 0 #0 is the best possible factor, indicates limited dimer formation
    if dimer_monomer_factor > max_dimer_monomer_factor:
        dimer_monomer_factor = max_dimer_monomer_factor #cap cost of having a poor monomer formation

    if hot:
        score_nucl = nucl_max_score - score_nucl
    
    return (dimer_monomer_factor, score_nucl)
    
def vienna_dimer_energy(seq:str, temp:float, is_rna: bool) -> float:
    if not is_rna:
        RNA.params_load_DNA_Mathews2004()
    else:
        RNA.params_load_defaults()
    model = RNA.md()
    model.temperature = temp
    model.compute_bpp = 0
    model.gquad = 1
    fc = RNA.fold_compound(seq + "&" + seq, model)
    dimer_energy = fc.pf()[1]
    return dimer_energy

def vienna_score_energy(seq:str, temp:float, target_energy: float, free_energy_max_score: float, is_rna: bool) -> float:
    if not is_rna:
        RNA.params_load_DNA_Mathews2004()
    else:
        RNA.params_load_defaults()
    model = RNA.md()
    model.temperature = temp
    model.compute_bpp = 0
    model.gquad = 1
    fc = RNA.fold_compound(seq, model)
    ensemble_energy = fc.pf()[1]

    score_free_energy = (target_energy - ensemble_energy) / target_energy
    if score_free_energy < 0:
        score_free_energy = 0
    if score_free_energy > free_energy_max_score:
        score_free_energy = free_energy_max_score
    return score_free_energy
